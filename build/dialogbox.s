;
; File generated by cc65 v 2.18 - N/A
;
	.fopt		compiler,"cc65 v 2.18 - N/A"
	.setcpu		"6502"
	.smart		on
	.autoimport	on
	.case		on
	.debuginfo	off
	.importzp	sp, sreg, regsave, regbank
	.importzp	tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
	.macpack	longbranch
	.export		_trigger_dialog_box
	.export		_dbox_draw_box
	.export		_dbox_draw_text
	.export		_dbox_await_input
	.export		_dbox_erase_box
	.export		_dbox_erase_text
	.export		_dbox_erase_text_addr_calc_sub
	.import		_one_vram_buffer
	.import		_multi_vram_buffer_horz
	.import		_add_scroll_y_fast_sub
	.import		_set_data_pointer
	.importzp	_TEMP
	.export		_active_dboxdata
	.export		_dbox_status
	.export		_dbox_x
	.export		_dbox_y
	.export		_dbox_string_index
	.export		_dbox_char_index
	.export		_dbox_erase_text_frame
	.export		_dbox_current_string
	.export		_dbox_string_array
	.export		_dbox_sprite_array
	.importzp	_temp0
	.importzp	_pad1_new
	.importzp	_address
	.importzp	_temppointer
	.importzp	_scroll_y
	.importzp	_pseudo_scroll_y
	.importzp	_nt
	.importzp	_scroll_count
	.importzp	_game_mode
	.importzp	_debug_tile_y
	.import		_cmaps
	.import		_draw_screen_sub
	.import		_set_prg_bank
	.export		_dbox_tiles
	.export		_empty_string
	.export		_dbox_functions
	.export		_dialog_box_handler
	.export		_dbox_erase_text_x_values
	.export		_dbox_erase_text_y_values
	.export		_dbox_erase_text_lengths

.segment	"DATA"

_dbox_functions:
	.addr	_dbox_draw_box
	.addr	_dbox_erase_box
	.addr	_dbox_draw_text
	.addr	_dbox_await_input
	.addr	_dbox_erase_text

.segment	"RODATA"

_dbox_tiles:
	.byte	$2C
	.byte	$2C
	.byte	$2C
	.byte	$2C
	.byte	$2C
	.byte	$2C
	.byte	$2C
	.byte	$2C
	.byte	$2C
	.byte	$2C
	.byte	$2C
	.byte	$2C
	.byte	$2C
	.byte	$2C
	.byte	$2C
	.byte	$2C
	.byte	$2C
	.byte	$2C
	.byte	$2C
	.byte	$2C
	.byte	$2C
	.byte	$2C
	.byte	$2C
	.byte	$2C
	.byte	$2C
	.byte	$2C
	.byte	$2C
	.byte	$2C
	.byte	$2C
	.byte	$2C
	.byte	$2C
	.byte	$2C
	.byte	$2C
	.byte	$2C
	.byte	$2C
	.byte	$2C
	.byte	$2C
	.byte	$2C
	.byte	$2C
	.byte	$2C
	.byte	$2C
	.byte	$2C
	.byte	$2C
	.byte	$2C
	.byte	$2C
	.byte	$2C
	.byte	$2C
	.byte	$2C
	.byte	$31
	.byte	$31
	.byte	$31
	.byte	$31
	.byte	$31
	.byte	$31
	.byte	$31
	.byte	$31
	.byte	$31
	.byte	$31
	.byte	$31
	.byte	$31
	.byte	$31
	.byte	$31
	.byte	$31
	.byte	$31
_empty_string:
	.byte	$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20
	.byte	$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$00
_dbox_erase_text_x_values:
	.byte	$02
	.byte	$02
	.byte	$02
	.byte	$02
_dbox_erase_text_y_values:
	.byte	$03
	.byte	$04
	.byte	$05
	.byte	$06
_dbox_erase_text_lengths:
	.byte	$1C
	.byte	$1C

.segment	"BSS"

_active_dboxdata:
	.res	2,$00
_dbox_status:
	.res	1,$00
_dbox_x:
	.res	1,$00
_dbox_y:
	.res	1,$00
_dbox_string_index:
	.res	1,$00
_dbox_char_index:
	.res	1,$00
_dbox_erase_text_frame:
	.res	1,$00
_dbox_current_string:
	.res	2,$00
_dbox_string_array:
	.res	2,$00
_dbox_sprite_array:
	.res	2,$00

; ---------------------------------------------------------------
; void __near__ trigger_dialog_box (__near__ const struct DialogBoxData_t *)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_trigger_dialog_box: near

.segment	"CODE"

;
; void trigger_dialog_box(DialogBoxData const * dboxdata) {
;
	jsr     pushax
;
; active_dboxdata = dboxdata;
;
	ldy     #$01
	lda     (sp),y
	sta     _active_dboxdata+1
	dey
	lda     (sp),y
	sta     _active_dboxdata
;
; game_mode = MODE_GAME_SHOWING_TEXT;
;
	lda     #$05
	sta     _game_mode
;
; dbox_status = DBOX_STATUS_DRAWING_BOX;
;
	tya
	sta     _dbox_status
;
; dbox_y = 0;
;
	sta     _dbox_y
;
; dbox_string_index = 0;
;
	sta     _dbox_string_index
;
; dbox_char_index = 0;
;
	sta     _dbox_char_index
;
; dbox_current_string = dboxdata->strings[0];
;
	iny
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$03
	lda     (ptr1),y
	tax
	dey
	lda     (ptr1),y
	sta     ptr1
	stx     ptr1+1
	dey
	lda     (ptr1),y
	sta     _dbox_current_string+1
	dey
	lda     (ptr1),y
	sta     _dbox_current_string
;
; }
;
	jmp     incsp2

.endproc

; ---------------------------------------------------------------
; void __near__ dbox_draw_box (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_dbox_draw_box: near

.segment	"CODE"

;
; set_data_pointer(dbox_tiles);
;
	lda     #<(_dbox_tiles)
	ldx     #>(_dbox_tiles)
	jsr     _set_data_pointer
;
; add_scroll_y(pseudo_scroll_y, dbox_y, scroll_y);
;
	lda     _scroll_y
	sta     _TEMP
	lda     _scroll_y+1
	sta     _TEMP+1
	lda     _dbox_y
	jsr     _add_scroll_y_fast_sub
	sta     _pseudo_scroll_y
	stx     _pseudo_scroll_y+1
;
; draw_screen_sub();
;
	jsr     _draw_screen_sub
;
; if (scroll_count == 0) {
;
	lda     _scroll_count
	bne     L0144
;
; dbox_y += 0x20;
;
	lda     #$20
	clc
	adc     _dbox_y
	sta     _dbox_y
;
; if (dbox_y > 0x20) { // ...but there are only two rows.
;
L0144:	lda     _dbox_y
	cmp     #$21
	bcc     L0090
;
; dbox_status = DBOX_STATUS_DRAWING_TEXT;
;
	lda     #$02
	sta     _dbox_status
;
; dbox_x = TEXT_START_X;
;
	sta     _dbox_x
;
; dbox_y = TEXT_START_Y;
;
	lda     #$03
	sta     _dbox_y
;
; }
;
L0090:	rts

.endproc

; ---------------------------------------------------------------
; void __near__ dbox_draw_text (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_dbox_draw_text: near

.segment	"CODE"

;
; set_prg_bank(0);
;
	lda     #$00
	jsr     _set_prg_bank
;
; temp0 = dbox_current_string[dbox_char_index];
;
	lda     _dbox_current_string
	ldx     _dbox_current_string+1
	ldy     _dbox_char_index
	sta     ptr1
	stx     ptr1+1
	lda     (ptr1),y
	sta     _temp0
;
; ++dbox_char_index; 
;
	inc     _dbox_char_index
;
; if (temp0 == '\0') {
;
	ldx     #$00
	lda     _temp0
	bne     L0148
;
; dbox_status = DBOX_STATUS_AWAITING_BUTTON;
;
	lda     #$03
	sta     _dbox_status
;
; } else if (temp0 == '\n') {
;
	rts
L0148:	lda     _temp0
	cmp     #$0A
;
; } else {
;
	beq     L014E
;
; if (nt == 0) {
;
	lda     _nt
	bne     L014A
;
; address = NTADR_A(dbox_x, dbox_y);
;
	lda     _dbox_y
	jsr     aslax4
	stx     tmp1
	asl     a
	rol     tmp1
	sta     ptr1
	lda     _dbox_x
	ora     ptr1
	sta     _address
	lda     tmp1
	ora     #$20
;
; } else {
;
	jmp     L014C
;
; address = NTADR_C(dbox_x, dbox_y);
;
L014A:	lda     _dbox_y
	jsr     aslax4
	stx     tmp1
	asl     a
	rol     tmp1
	sta     ptr1
	lda     _dbox_x
	ora     ptr1
	sta     _address
	lda     tmp1
	ora     #$28
L014C:	sta     _address+1
;
; one_vram_buffer(temp0, address);
;
	lda     _temp0
	jsr     pusha
	lda     _address
	ldx     _address+1
	jsr     _one_vram_buffer
;
; ++dbox_x;
;
	inc     _dbox_x
;
; if (dbox_x >= TEXT_END_X) {
;
	lda     _dbox_x
	cmp     #$1E
	bcc     L00BF
;
; dbox_x = TEXT_START_X;
;
L014E:	lda     #$02
	sta     _dbox_x
;
; ++dbox_y;
;
	inc     _dbox_y
;
; }
;
L00BF:	rts

.endproc

; ---------------------------------------------------------------
; void __near__ dbox_await_input (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_dbox_await_input: near

.segment	"CODE"

;
; set_prg_bank(0);
;
	lda     #$00
	jsr     _set_prg_bank
;
; debug_tile_y = active_dboxdata->count;
;
	lda     _active_dboxdata+1
	sta     ptr1+1
	lda     _active_dboxdata
	sta     ptr1
	ldy     #$04
	lda     (ptr1),y
	sta     _debug_tile_y
;
; if (pad1_new & PAD_DOWN) {
;
	lda     _pad1_new
	and     #$04
	beq     L00D2
;
; ++dbox_string_index;
;
	inc     _dbox_string_index
;
; if (dbox_string_index == active_dboxdata->count) { 
;
	lda     _dbox_string_index
	jsr     pusha0
	lda     _active_dboxdata+1
	sta     ptr1+1
	lda     _active_dboxdata
	sta     ptr1
	ldy     #$04
	lda     (ptr1),y
	jsr     tosicmp0
	bne     L00CC
;
; dbox_status = DBOX_STATUS_ERASING_BOX;
;
	lda     #$01
	sta     _dbox_status
;
; dbox_y = 0;
;
	lda     #$00
	sta     _dbox_y
;
; } else {
;
	rts
;
; dbox_current_string = active_dboxdata->strings[dbox_string_index];
;
L00CC:	lda     _active_dboxdata+1
	sta     ptr1+1
	lda     _active_dboxdata
	sta     ptr1
	ldy     #$03
	lda     (ptr1),y
	tax
	dey
	lda     (ptr1),y
	sta     ptr1
	stx     ptr1+1
	ldx     #$00
	lda     _dbox_string_index
	asl     a
	bcc     L0150
	inx
	clc
L0150:	adc     ptr1
	sta     ptr1
	txa
	adc     ptr1+1
	sta     ptr1+1
	dey
	lda     (ptr1),y
	sta     _dbox_current_string+1
	dey
	lda     (ptr1),y
	sta     _dbox_current_string
;
; dbox_status = DBOX_STATUS_ERASING_TEXT;
;
	lda     #$04
	sta     _dbox_status
;
; dbox_char_index = 0;
;
	sty     _dbox_char_index
;
; dbox_x = TEXT_START_X;
;
	lda     #$02
	sta     _dbox_x
;
; dbox_y = TEXT_START_Y;
;
	lda     #$03
	sta     _dbox_y
;
; dbox_erase_text_frame = 0;
;
	sty     _dbox_erase_text_frame
;
; }
;
L00D2:	rts

.endproc

; ---------------------------------------------------------------
; void __near__ dbox_erase_box (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_dbox_erase_box: near

.segment	"CODE"

;
; add_scroll_y(pseudo_scroll_y, dbox_y, scroll_y);
;
	lda     _scroll_y
	sta     _TEMP
	lda     _scroll_y+1
	sta     _TEMP+1
	lda     _dbox_y
	jsr     _add_scroll_y_fast_sub
	sta     _pseudo_scroll_y
	stx     _pseudo_scroll_y+1
;
; temp0 = high_byte(pseudo_scroll_y);
;
	lda     _pseudo_scroll_y+1
	sta     _temp0
;
; AsmSet2ByteFromPtrAtIndexVar(temppointer, cmaps, temp0);
;
	asl     a
	tay
	lda     _cmaps,y
	sta     _temppointer
	lda     _cmaps+1,y
	sta     _temppointer+1
;
; set_data_pointer(temppointer);
;
	lda     _temppointer
	ldx     _temppointer+1
	jsr     _set_data_pointer
;
; draw_screen_sub();
;
	jsr     _draw_screen_sub
;
; if (scroll_count == 0) {
;
	lda     _scroll_count
	bne     L0151
;
; dbox_y += 0x20;
;
	lda     #$20
	clc
	adc     _dbox_y
	sta     _dbox_y
;
; if (dbox_y > 0x20) {
;
L0151:	lda     _dbox_y
	cmp     #$21
	bcc     L0140
;
; game_mode = MODE_GAME;
;
	lda     #$01
	sta     _game_mode
;
; }
;
L0140:	rts

.endproc

; ---------------------------------------------------------------
; void __near__ dbox_erase_text (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_dbox_erase_text: near

.segment	"CODE"

;
; for (temp0 = 0; temp0 < 2; ++temp0) {
;
	lda     #$00
	sta     _temp0
L0152:	lda     _temp0
	cmp     #$02
	bcs     L0153
;
; dbox_x = dbox_erase_text_x_values[dbox_erase_text_frame];
;
	ldy     _dbox_erase_text_frame
	lda     _dbox_erase_text_x_values,y
	sta     _dbox_x
;
; dbox_y = dbox_erase_text_y_values[dbox_erase_text_frame];
;
	ldy     _dbox_erase_text_frame
	lda     _dbox_erase_text_y_values,y
	sta     _dbox_y
;
; address = dbox_erase_text_addr_calc_sub();
;
	jsr     _dbox_erase_text_addr_calc_sub
	sta     _address
	stx     _address+1
;
; multi_vram_buffer_horz(empty_string, dbox_erase_text_lengths[temp0], address);
;
	jsr     decsp3
	lda     #<(_empty_string)
	ldy     #$01
	sta     (sp),y
	iny
	lda     #>(_empty_string)
	sta     (sp),y
	ldy     _temp0
	lda     _dbox_erase_text_lengths,y
	ldy     #$00
	sta     (sp),y
	lda     _address
	ldx     _address+1
	jsr     _multi_vram_buffer_horz
;
; ++dbox_erase_text_frame;
;
	inc     _dbox_erase_text_frame
;
; for (temp0 = 0; temp0 < 2; ++temp0) {
;
	inc     _temp0
	jmp     L0152
;
; if (dbox_erase_text_frame == 4) {
;
L0153:	lda     _dbox_erase_text_frame
	cmp     #$04
	bne     L0114
;
; dbox_status = DBOX_STATUS_DRAWING_TEXT;
;
	lda     #$02
	sta     _dbox_status
;
; dbox_x = TEXT_START_X;
;
	sta     _dbox_x
;
; dbox_y = TEXT_START_Y;
;
	lda     #$03
	sta     _dbox_y
;
; }
;
L0114:	rts

.endproc

; ---------------------------------------------------------------
; int __near__ dbox_erase_text_addr_calc_sub (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_dbox_erase_text_addr_calc_sub: near

.segment	"CODE"

;
; if (nt == 0) {
;
	ldx     #$00
	lda     _nt
	bne     L0155
;
; return NTADR_A(dbox_x, dbox_y);
;
	lda     _dbox_y
	jsr     aslax4
	stx     tmp1
	asl     a
	rol     tmp1
	sta     ptr1
	lda     _dbox_x
	ora     ptr1
	pha
	lda     tmp1
	ora     #$20
	jmp     L0156
;
; return NTADR_C(dbox_x, dbox_y);
;
L0155:	lda     _dbox_y
	jsr     aslax4
	stx     tmp1
	asl     a
	rol     tmp1
	sta     ptr1
	lda     _dbox_x
	ora     ptr1
	pha
	lda     tmp1
	ora     #$28
L0156:	tax
	pla
;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; void __near__ dialog_box_handler (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_dialog_box_handler: near

.segment	"CODE"

;
; AsmCallFunctionAtPtrOffsetByIndexVar(dbox_functions, dbox_status);
;
	lda     _dbox_status
	asl     a
	tay
	lda     _dbox_functions,y
	ldx     _dbox_functions+1,y
	jmp     callax

.endproc

