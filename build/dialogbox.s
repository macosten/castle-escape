;
; File generated by cc65 v 2.18 - N/A
;
	.fopt		compiler,"cc65 v 2.18 - N/A"
	.setcpu		"6502"
	.smart		on
	.autoimport	on
	.case		on
	.debuginfo	off
	.importzp	sp, sreg, regsave, regbank
	.importzp	tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
	.macpack	longbranch
	.export		_trigger_dialog_box
	.export		_dbox_draw_box
	.export		_dbox_draw_text
	.export		_dbox_await_input
	.export		_dbox_erase_box
	.export		_dbox_erase_text
	.export		_dbox_erase_text_addr_calc_sub
	.import		_one_vram_buffer
	.import		_multi_vram_buffer_horz
	.import		_add_scroll_y_fast_sub
	.import		_set_data_pointer
	.importzp	_TEMP
	.import		_oam_spr_fast_sub
	.export		_active_dboxdata
	.export		_dbox_status
	.export		_dbox_x
	.export		_dbox_y
	.export		_dbox_string_index
	.export		_dbox_char_index
	.export		_dbox_erase_text_frame
	.export		_dbox_current_string
	.importzp	_temp0
	.importzp	_temp1
	.importzp	_pad1_new
	.importzp	_address
	.importzp	_temppointer
	.importzp	_scroll_y
	.importzp	_pseudo_scroll_y
	.importzp	_nt
	.importzp	_scroll_count
	.importzp	_game_mode
	.import		_cmaps
	.import		_draw_screen_sub
	.import		_set_prg_bank
	.export		_dbox_tiles
	.export		_dbox_downward_cursor_y_offset_table
	.export		_empty_string
	.export		_dbox_functions
	.export		_dialog_box_handler
	.export		_dbox_erase_text_x_values
	.export		_dbox_erase_text_y_values
	.export		_dbox_erase_text_lengths

.segment	"RODATA"

_dbox_tiles:
	.byte	$2C
	.byte	$2C
	.byte	$2C
	.byte	$2C
	.byte	$2C
	.byte	$2C
	.byte	$2C
	.byte	$2C
	.byte	$2C
	.byte	$2C
	.byte	$2C
	.byte	$2C
	.byte	$2C
	.byte	$2C
	.byte	$2C
	.byte	$2C
	.byte	$2C
	.byte	$2C
	.byte	$2C
	.byte	$2C
	.byte	$2C
	.byte	$2C
	.byte	$2C
	.byte	$2C
	.byte	$2C
	.byte	$2C
	.byte	$2C
	.byte	$2C
	.byte	$2C
	.byte	$2C
	.byte	$2C
	.byte	$2C
	.byte	$2C
	.byte	$2C
	.byte	$2C
	.byte	$2C
	.byte	$2C
	.byte	$2C
	.byte	$2C
	.byte	$2C
	.byte	$2C
	.byte	$2C
	.byte	$2C
	.byte	$2C
	.byte	$2C
	.byte	$2C
	.byte	$2C
	.byte	$2C
	.byte	$31
	.byte	$31
	.byte	$31
	.byte	$31
	.byte	$31
	.byte	$31
	.byte	$31
	.byte	$31
	.byte	$31
	.byte	$31
	.byte	$31
	.byte	$31
	.byte	$31
	.byte	$31
	.byte	$31
	.byte	$31
_dbox_downward_cursor_y_offset_table:
	.byte	$30
	.byte	$31
	.byte	$32
	.byte	$31
_empty_string:
	.byte	$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20
	.byte	$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$00
_dbox_functions:
	.addr	_dbox_draw_box
	.addr	_dbox_erase_box
	.addr	_dbox_draw_text
	.addr	_dbox_await_input
	.addr	_dbox_erase_text
_dbox_erase_text_x_values:
	.byte	$02
	.byte	$02
	.byte	$02
	.byte	$02
_dbox_erase_text_y_values:
	.byte	$03
	.byte	$04
	.byte	$05
	.byte	$06
_dbox_erase_text_lengths:
	.byte	$1C
	.byte	$1C

.segment	"BSS"

_active_dboxdata:
	.res	5,$00
_dbox_status:
	.res	1,$00
_dbox_x:
	.res	1,$00
_dbox_y:
	.res	1,$00
_dbox_string_index:
	.res	1,$00
_dbox_char_index:
	.res	1,$00
_dbox_erase_text_frame:
	.res	1,$00
_dbox_current_string:
	.res	2,$00

; ---------------------------------------------------------------
; void __near__ trigger_dialog_box (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_trigger_dialog_box: near

.segment	"CODE"

;
; game_mode = MODE_GAME_SHOWING_TEXT;
;
	lda     #$05
	sta     _game_mode
;
; dbox_status = DBOX_STATUS_DRAWING_BOX;
;
	lda     #$00
	sta     _dbox_status
;
; dbox_y = 0;
;
	sta     _dbox_y
;
; dbox_string_index = 0;
;
	sta     _dbox_string_index
;
; dbox_char_index = 0;
;
	sta     _dbox_char_index
;
; dbox_current_string = active_dboxdata.strings[0];
;
	lda     _active_dboxdata+2+1
	sta     ptr1+1
	lda     _active_dboxdata+2
	sta     ptr1
	ldy     #$01
	lda     (ptr1),y
	sta     _dbox_current_string+1
	dey
	lda     (ptr1),y
	sta     _dbox_current_string
;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; void __near__ dbox_draw_box (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_dbox_draw_box: near

.segment	"CODE"

;
; set_data_pointer(dbox_tiles);
;
	lda     #<(_dbox_tiles)
	ldx     #>(_dbox_tiles)
	jsr     _set_data_pointer
;
; add_scroll_y(pseudo_scroll_y, dbox_y, scroll_y);
;
	lda     _scroll_y
	sta     _TEMP
	lda     _scroll_y+1
	sta     _TEMP+1
	lda     _dbox_y
	jsr     _add_scroll_y_fast_sub
	sta     _pseudo_scroll_y
	stx     _pseudo_scroll_y+1
;
; temp1 = high_byte(pseudo_scroll_y);
;
	lda     _pseudo_scroll_y+1
	sta     _temp1
;
; draw_screen_sub();
;
	jsr     _draw_screen_sub
;
; if (scroll_count == 0) {
;
	lda     _scroll_count
	bne     L0157
;
; dbox_y += 0x20;
;
	lda     #$20
	clc
	adc     _dbox_y
	sta     _dbox_y
;
; if (dbox_y > 0x20) { // ...but there are only two rows.
;
L0157:	lda     _dbox_y
	cmp     #$21
	bcc     L008C
;
; dbox_status = DBOX_STATUS_DRAWING_TEXT;
;
	lda     #$02
	sta     _dbox_status
;
; dbox_x = TEXT_START_X;
;
	sta     _dbox_x
;
; dbox_y = TEXT_START_Y;
;
	lda     #$03
	sta     _dbox_y
;
; }
;
L008C:	rts

.endproc

; ---------------------------------------------------------------
; void __near__ dbox_draw_text (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_dbox_draw_text: near

.segment	"CODE"

;
; set_prg_bank(0);
;
	lda     #$00
	jsr     _set_prg_bank
;
; temp0 = dbox_current_string[dbox_char_index];
;
	lda     _dbox_current_string
	ldx     _dbox_current_string+1
	ldy     _dbox_char_index
	sta     ptr1
	stx     ptr1+1
	lda     (ptr1),y
	sta     _temp0
;
; ++dbox_char_index; 
;
	inc     _dbox_char_index
;
; if (temp0 == '\0') {
;
	ldx     #$00
	lda     _temp0
	bne     L015B
;
; dbox_status = DBOX_STATUS_AWAITING_BUTTON;
;
	lda     #$03
	sta     _dbox_status
;
; dbox_y = 0;
;
	stx     _dbox_y
;
; } else if (temp0 == '\n') {
;
	rts
L015B:	lda     _temp0
	cmp     #$0A
;
; } else {
;
	beq     L0161
;
; if (nt == 0) {
;
	lda     _nt
	bne     L015D
;
; address = NTADR_A(dbox_x, dbox_y);
;
	lda     _dbox_y
	jsr     aslax4
	stx     tmp1
	asl     a
	rol     tmp1
	sta     ptr1
	lda     _dbox_x
	ora     ptr1
	sta     _address
	lda     tmp1
	ora     #$20
;
; } else {
;
	jmp     L015F
;
; address = NTADR_C(dbox_x, dbox_y);
;
L015D:	lda     _dbox_y
	jsr     aslax4
	stx     tmp1
	asl     a
	rol     tmp1
	sta     ptr1
	lda     _dbox_x
	ora     ptr1
	sta     _address
	lda     tmp1
	ora     #$28
L015F:	sta     _address+1
;
; one_vram_buffer(temp0, address);
;
	lda     _temp0
	jsr     pusha
	lda     _address
	ldx     _address+1
	jsr     _one_vram_buffer
;
; ++dbox_x;
;
	inc     _dbox_x
;
; if (dbox_x >= TEXT_END_X) {
;
	lda     _dbox_x
	cmp     #$1E
	bcc     L00BD
;
; dbox_x = TEXT_START_X;
;
L0161:	lda     #$02
	sta     _dbox_x
;
; ++dbox_y;
;
	inc     _dbox_y
;
; }
;
L00BD:	rts

.endproc

; ---------------------------------------------------------------
; void __near__ dbox_await_input (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_dbox_await_input: near

.segment	"CODE"

;
; set_prg_bank(0);
;
	lda     #$00
	jsr     _set_prg_bank
;
; if (pad1_new) {
;
	lda     _pad1_new
	beq     L00C5
;
; ++dbox_string_index;
;
	inc     _dbox_string_index
;
; if (dbox_string_index == active_dboxdata.count) { 
;
	ldx     #$00
	lda     _active_dboxdata+4
	cmp     _dbox_string_index
	bne     L0166
;
; dbox_status = DBOX_STATUS_ERASING_BOX;
;
	lda     #$01
	sta     _dbox_status
;
; dbox_y = 0;
;
	txa
;
; } else {
;
	jmp     L0164
;
; dbox_current_string = active_dboxdata.strings[dbox_string_index];
;
L0166:	lda     _dbox_string_index
	asl     a
	bcc     L0165
	inx
	clc
L0165:	adc     _active_dboxdata+2
	sta     ptr1
	txa
	adc     _active_dboxdata+2+1
	sta     ptr1+1
	ldy     #$01
	lda     (ptr1),y
	sta     _dbox_current_string+1
	dey
	lda     (ptr1),y
	sta     _dbox_current_string
;
; dbox_status = DBOX_STATUS_ERASING_TEXT;
;
	lda     #$04
	sta     _dbox_status
;
; dbox_char_index = 0;
;
	sty     _dbox_char_index
;
; dbox_x = TEXT_START_X;
;
	lda     #$02
	sta     _dbox_x
;
; dbox_y = TEXT_START_Y;
;
	lda     #$03
	sta     _dbox_y
;
; dbox_erase_text_frame = 0;
;
	sty     _dbox_erase_text_frame
;
; } else {
;
	rts
;
; temp1 = dbox_y >> 3;
;
L00C5:	lda     _dbox_y
	lsr     a
	lsr     a
	lsr     a
	sta     _temp1
;
; temp0 = dbox_downward_cursor_y_offset_table[temp1];
;
	ldy     _temp1
	lda     _dbox_downward_cursor_y_offset_table,y
	sta     _temp0
;
; oam_spr(232, temp0, 0x11, 0);
;
	lda     #$E8
	sta     _TEMP
	lda     _temp0
	sta     _TEMP+1
	lda     #$11
	sta     _TEMP+2
	lda     #$00
	jsr     _oam_spr_fast_sub
;
; ++dbox_y;
;
	inc     _dbox_y
;
; dbox_y &= 0b11111;
;
	lda     _dbox_y
	and     #$1F
L0164:	sta     _dbox_y
;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; void __near__ dbox_erase_box (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_dbox_erase_box: near

.segment	"CODE"

;
; add_scroll_y(pseudo_scroll_y, dbox_y, scroll_y);
;
	lda     _scroll_y
	sta     _TEMP
	lda     _scroll_y+1
	sta     _TEMP+1
	lda     _dbox_y
	jsr     _add_scroll_y_fast_sub
	sta     _pseudo_scroll_y
	stx     _pseudo_scroll_y+1
;
; temp1 = high_byte(pseudo_scroll_y);
;
	lda     _pseudo_scroll_y+1
	sta     _temp1
;
; AsmSet2ByteFromPtrAtIndexVar(temppointer, cmaps, temp1);
;
	asl     a
	tay
	lda     _cmaps,y
	sta     _temppointer
	lda     _cmaps+1,y
	sta     _temppointer+1
;
; set_data_pointer(temppointer);
;
	lda     _temppointer
	ldx     _temppointer+1
	jsr     _set_data_pointer
;
; draw_screen_sub();
;
	jsr     _draw_screen_sub
;
; if (scroll_count == 0) {
;
	lda     _scroll_count
	bne     L0167
;
; dbox_y += 0x20;
;
	lda     #$20
	clc
	adc     _dbox_y
	sta     _dbox_y
;
; if (dbox_y > 0x20) {
;
L0167:	lda     _dbox_y
	cmp     #$21
	bcc     L0151
;
; game_mode = MODE_GAME;
;
	lda     #$01
	sta     _game_mode
;
; dbox_y = 0;
;
	lda     #$00
	sta     _dbox_y
;
; }
;
L0151:	rts

.endproc

; ---------------------------------------------------------------
; void __near__ dbox_erase_text (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_dbox_erase_text: near

.segment	"CODE"

;
; for (temp0 = 0; temp0 < 2; ++temp0) {
;
	lda     #$00
	sta     _temp0
L0168:	lda     _temp0
	cmp     #$02
	bcs     L0169
;
; dbox_x = dbox_erase_text_x_values[dbox_erase_text_frame];
;
	ldy     _dbox_erase_text_frame
	lda     _dbox_erase_text_x_values,y
	sta     _dbox_x
;
; dbox_y = dbox_erase_text_y_values[dbox_erase_text_frame];
;
	ldy     _dbox_erase_text_frame
	lda     _dbox_erase_text_y_values,y
	sta     _dbox_y
;
; address = dbox_erase_text_addr_calc_sub();
;
	jsr     _dbox_erase_text_addr_calc_sub
	sta     _address
	stx     _address+1
;
; multi_vram_buffer_horz(empty_string, dbox_erase_text_lengths[temp0], address);
;
	jsr     decsp3
	lda     #<(_empty_string)
	ldy     #$01
	sta     (sp),y
	iny
	lda     #>(_empty_string)
	sta     (sp),y
	ldy     _temp0
	lda     _dbox_erase_text_lengths,y
	ldy     #$00
	sta     (sp),y
	lda     _address
	ldx     _address+1
	jsr     _multi_vram_buffer_horz
;
; ++dbox_erase_text_frame;
;
	inc     _dbox_erase_text_frame
;
; for (temp0 = 0; temp0 < 2; ++temp0) {
;
	inc     _temp0
	jmp     L0168
;
; if (dbox_erase_text_frame == 4) {
;
L0169:	lda     _dbox_erase_text_frame
	cmp     #$04
	bne     L0125
;
; dbox_status = DBOX_STATUS_DRAWING_TEXT;
;
	lda     #$02
	sta     _dbox_status
;
; dbox_x = TEXT_START_X;
;
	sta     _dbox_x
;
; dbox_y = TEXT_START_Y;
;
	lda     #$03
	sta     _dbox_y
;
; }
;
L0125:	rts

.endproc

; ---------------------------------------------------------------
; int __near__ dbox_erase_text_addr_calc_sub (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_dbox_erase_text_addr_calc_sub: near

.segment	"CODE"

;
; if (nt == 0) {
;
	ldx     #$00
	lda     _nt
	bne     L016B
;
; return NTADR_A(dbox_x, dbox_y);
;
	lda     _dbox_y
	jsr     aslax4
	stx     tmp1
	asl     a
	rol     tmp1
	sta     ptr1
	lda     _dbox_x
	ora     ptr1
	pha
	lda     tmp1
	ora     #$20
	jmp     L016C
;
; return NTADR_C(dbox_x, dbox_y);
;
L016B:	lda     _dbox_y
	jsr     aslax4
	stx     tmp1
	asl     a
	rol     tmp1
	sta     ptr1
	lda     _dbox_x
	ora     ptr1
	pha
	lda     tmp1
	ora     #$28
L016C:	tax
	pla
;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; void __near__ dialog_box_handler (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_dialog_box_handler: near

.segment	"CODE"

;
; AsmCallFunctionAtPtrOffsetByIndexVar(dbox_functions, dbox_status);
;
	lda     _dbox_status
	asl     a
	tay
	lda     _dbox_functions,y
	ldx     _dbox_functions+1,y
	jmp     callax

.endproc

